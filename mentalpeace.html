<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>UNSEEN</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html,body{
  margin:0;
  height:700vh;
  background:#040509;
  overflow-x:hidden;
}
canvas{ position:fixed; inset:0; }
</style>
</head>

<body>
<canvas id="c"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* CORE */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x040509, 20, 120);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 300);
camera.position.z = 55;

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("c"),
  antialias:true
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);

/* LIGHT */
const mainLight = new THREE.PointLight(0x9bb6ff, 3, 200);
mainLight.position.set(0,0,60);
scene.add(mainLight);

/* BRAIN POINT CLOUD */
const COUNT = 14000;
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(COUNT*3);
const base = [];

for(let i=0;i<COUNT;i++){
  // LOBE-LIKE DISTRIBUTION
  const r = 14 + Math.sin(i)*2;
  const t = Math.random()*Math.PI*2;
  const p = Math.acos(Math.random()*2-1);

  const x = r*Math.sin(p)*Math.cos(t) * (1 + Math.sin(t)*0.15);
  const y = r*Math.sin(p)*Math.sin(t) * (1 + Math.cos(p)*0.2);
  const z = r*Math.cos(p);

  pos.set([x,y,z], i*3);
  base.push({x,y,z});
}

geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

const mat = new THREE.PointsMaterial({
  size:0.12,
  color:0x88aaff,
  transparent:true,
  opacity:0.85,
  depthWrite:false
});

const brain = new THREE.Points(geo, mat);
scene.add(brain);

/* NEURAL CONNECTIONS */
const lineGeo = new THREE.BufferGeometry();
const linePos = [];
for(let i=0;i<3000;i++){
  const a = Math.floor(Math.random()*COUNT);
  const b = Math.floor(Math.random()*COUNT);
  linePos.push(
    base[a].x, base[a].y, base[a].z,
    base[b].x, base[b].y, base[b].z
  );
}
lineGeo.setAttribute("position", new THREE.Float32BufferAttribute(linePos,3));

const lineMat = new THREE.LineBasicMaterial({
  color:0x99bbff,
  transparent:true,
  opacity:0.05
});

const connections = new THREE.LineSegments(lineGeo, lineMat);
scene.add(connections);

/* SCROLL */
let scroll = 0;
addEventListener("scroll",()=>{
  scroll = window.scrollY / (document.body.scrollHeight - innerHeight);
});

/* ANIMATION LOOP */
function animate(){
  requestAnimationFrame(animate);

  const p = geo.attributes.position.array;

  for(let i=0;i<COUNT;i++){
    let {x,y,z} = base[i];

    // Anxiety vibration
    if(scroll > 0.2 && scroll < 0.4){
      const t = performance.now()*0.01 + i;
      x += Math.sin(t)*0.6;
      y += Math.cos(t)*0.6;
    }

    // Depression collapse
    if(scroll > 0.4 && scroll < 0.6){
      const f = 1 - (scroll-0.4)*2;
      x *= f; y *= f; z *= f;
    }

    // Burnout fragmentation
    if(scroll > 0.6 && scroll < 0.8){
      x += (Math.random()-0.5)*3;
      y += (Math.random()-0.5)*3;
      z += (Math.random()-0.5)*3;
    }

    // Resilience (imperfect)
    if(scroll > 0.8){
      const r = 0.8 + (scroll-0.8);
      x *= r; y *= r; z *= r;
    }

    p[i*3]=x; p[i*3+1]=y; p[i*3+2]=z;
  }

  geo.attributes.position.needsUpdate = true;

  // Camera narrative
  camera.position.z = 55 - scroll*28;
  camera.rotation.z = scroll*0.2;

  // Emotional lighting
  mainLight.color.setHSL(0.6 - scroll*0.35, 0.7, 0.6);

  // Connection intensity
  lineMat.opacity = scroll < 0.4 ? 0.12 :
                    scroll < 0.6 ? 0.04 :
                    scroll < 0.8 ? 0.01 : 0.06;

  renderer.render(scene,camera);
}
animate();

/* RESIZE */
addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
